---
id: dmoj-phidias
source: DMOJ
title: phidias
author: Andrew Cheng
---

## Solution

Let $dp[i][j]$ be the amount of waste material for a rectangle with width $i$ and height $j$. This rectangle of width $i$ and height $j$ can be split into two smaller rectangles (marked in red and green) after removing a plate that Phidias wants (marked in blue). There are two different possible ways to split the remaining shape into two rectangles.

Case1: 

<center>

<table>
    <tbody>
        <tr>
            <td className="bg-red-100 dark:bg-red-800">  1  </td>
            <td className="bg-red-100 dark:bg-red-800">  1  </td>
        </tr>
        <tr>
            <td className="bg-green-100 dark:bg-green-800">  2  </td>
            <td className="bg-blue-100 dark:bg-blue-800">  3  </td>
        </tr>
    </tbody>
</table>

</center>

Case2: 

<center>

<table>
    <tbody>
        <tr>
            <td className="bg-red-100 dark:bg-red-800">  1  </td>
            <td className="bg-green-100 dark:bg-green-800">  2  </td>
        </tr>
        <tr>
            <td className="bg-red-100 dark:bg-red-800">  1  </td>
            <td className="bg-blue-100 dark:bg-blue-800">  3  </td>
        </tr>
    </tbody>
</table>

</center>

We loop through all $N$ possible marble plates for each $i$ and $j$. Mathematically, the transition formula is as follows:

$dp[i][j] = min_k (dp[i][j], dp[i][j-k.h] + dp[i-k.w][k.h], dp[i-k.w][j] + dp[k.w][j-k.h])$

where $k$ is current marble plate under consideration.

**Time Complexity:**
$\mathcal{O}(NWH)$

## Implementation

<LanguageSection>
<CPPSection>

```cpp

#include <bits/stdc++.h>
#define pi pair<int,int>
#define f first
#define s second
using namespace std;

const int maxW = 600;
const int maxN = 200;

pi a[maxN+1];
int dp[maxW+1][maxW+1];
int N,W,H;

int main(){
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cin >> W >> H >> N;
	for(int i = 1; i <= N; ++i){
        cin >> a[i].f >> a[i].s;
    }
	for(int i = 1; i <= W; ++i){
		for(int j = 1; j <= H; ++j){
			dp[i][j] = i * j;
		}
	}
	for(int i = 1; i <= N; ++i){
        dp[a[i].f][a[i].s] = 0;
    }
	for(int i = 1; i <= W; ++i){
		for(int j = 1; j <= H; ++j){
			for(int k = 1; k <= N; ++k){
				if(i < a[k].f || j < a[k].s)continue;
				dp[i][j] = min(dp[i][j], dp[i][j -a[k].s] + dp[i - a[k].f][a[k].s]);
				dp[i][j] = min(dp[i][j], dp[i - a[k].f][j] + dp[a[k].f][j - a[k].s]);
			}
		}
	}
	cout << dp[W][H] << '\n';
}

```
</CPPSection>
</LanguageSection>
